import { OutPoint, Cell, config, Indexer, RPC, hd, commons } from "@ckb-lumos/lumos";
import { TransactionSkeleton, encodeToAddress, sealTransaction } from "@ckb-lumos/helpers";

const CKB_RPC_URL = "https://testnet.ckb.dev/rpc";
const CKB_INDEXER_URL = "https://testnet.ckb.dev/indexer";

const rpc = new RPC(CKB_RPC_URL);
const indexer = new Indexer(CKB_INDEXER_URL, CKB_RPC_URL);
config.initializeConfig(config.predefined.AGGRON4);

export const generateHDAccount = (privKey: string)=> {  
  const pubKey = hd.key.privateToPublic(privKey);
  const args = hd.key.publicKeyToBlake160(pubKey);
  const template = config.getConfig().SCRIPTS["SECP256K1_BLAKE160"]!;
  const lockScript = {
    codeHash: template.CODE_HASH,
    hashType: template.HASH_TYPE,
    args: args,
  };

  const address = encodeToAddress(lockScript);

  return {
    lockScript,
    address,
    pubKey,
    privKey,
  };
};

export const getCellByOutPoint = async (outpoint: OutPoint): Promise<Cell> => {
  const tx = await rpc.getTransaction(outpoint.txHash);
  if (!tx) {
    throw new Error(`not found tx: ${outpoint.txHash}`)
  }

  const block = await rpc.getBlock(tx.txStatus.blockHash!);
  return {
    cellOutput: tx.transaction.outputs[0], 
    data: tx.transaction.outputsData[0],
    outPoint: outpoint,
    blockHash: tx.txStatus.blockHash,
    blockNumber: block!.header.number,
  }
}

export const deposit = async (fromAddress: string, privKey: string) => {
  let txSkeleton = TransactionSkeleton({ cellProvider: indexer });

  txSkeleton = await commons.dao.deposit(
    txSkeleton,
    fromAddress,
    fromAddress,
    BigInt(1000 * 10 ** 8),
  );

  txSkeleton = await commons.common.payFeeByFeeRate(
    txSkeleton,
    [fromAddress],
    1000,
  );

  txSkeleton = commons.common.prepareSigningEntries(txSkeleton);
  const message = txSkeleton.get("signingEntries").get(0)?.message;
  const Sig = hd.key.signRecoverable(message!, privKey);
  const tx = sealTransaction(txSkeleton, [Sig]);

  const hash = await rpc.sendTransaction(tx, "passthrough");
  return hash;
}

export const withdraw = async (depositOutpoint: OutPoint, fromAddress: string, privKey: string) => {
  let txSkeleton = TransactionSkeleton({ cellProvider: indexer });

  const depositCell = await getCellByOutPoint(depositOutpoint);

  txSkeleton = await commons.dao.withdraw(
    txSkeleton,
    depositCell,
    fromAddress
  );

  txSkeleton = await commons.common.payFeeByFeeRate(
    txSkeleton,
    [fromAddress],
    1000,
  );

  txSkeleton = commons.common.prepareSigningEntries(txSkeleton);
  const message = txSkeleton.get("signingEntries").get(0)?.message;
  const Sig = hd.key.signRecoverable(message!, privKey);
  const tx = sealTransaction(txSkeleton, [Sig]);

  const hash = await rpc.sendTransaction(tx, "passthrough");
  return hash;
}

export const unlock = async (
  depositOutpoint: OutPoint,
  withdrawOutpoint: OutPoint,
  fromAddress: string,
  privKey: string,
) => {
  let txSkeleton = TransactionSkeleton({ cellProvider: indexer });

  const depositCell = await getCellByOutPoint(depositOutpoint);
  const withdrawCell = await getCellByOutPoint(withdrawOutpoint);

  txSkeleton = await commons.dao.unlock(
    txSkeleton,
    depositCell,
    withdrawCell,
    fromAddress,
    fromAddress,
  );

  txSkeleton = await commons.common.payFeeByFeeRate(
    txSkeleton,
    [fromAddress],
    1000,
  );

  txSkeleton = commons.common.prepareSigningEntries(txSkeleton);
  const message = txSkeleton.get("signingEntries").get(0)?.message;
  const Sig = hd.key.signRecoverable(message!, privKey);
  const tx = sealTransaction(txSkeleton, [Sig]);

  const hash = await rpc.sendTransaction(tx, "passthrough");
  return hash;
}

const bootstrap = async () => {
  // generated by https://ckb.tools/generator
  const alice = generateHDAccount('0x36af8b48513f4e354313ecd328701be02b76dcadb88194a5c77563dacb29f739');

  const depositTx = await deposit(alice.address, alice.privKey);
  const depositOutpoint = { txHash: depositTx, index: '0x0' }
  console.log('depositOutpoint: ', depositOutpoint)

  // const withdrawTx = await withdraw(depositOutpoint, alice.address, alice.privKey)
  // const withdrawOutpoint = { txHash: withdrawTx, index: '0x0' }
  // console.log('withdrawOutpoint: ', withdrawOutpoint)


  // wait 180 epoch

  // const unlockTx = await unlock(
  //   depositOutpoint,
  //   withdrawOutpoint,
  //   alice.address,
  //   alice.privKey,
  // )

  // console.log('unlockTx is', unlockTx)
}

bootstrap()
